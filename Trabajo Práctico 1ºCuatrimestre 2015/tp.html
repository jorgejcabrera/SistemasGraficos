<html>

<head>
<title>Trabajo Práctico</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<!-- Acá indicamos las librerías a usar: -->
<script type="text/javascript" src="src/utils/gl-matrix.js"></script>
<script type="text/javascript" src="src/initBuffers.js"></script>
<script type="text/javascript" src="src/drawShapes.js"></script>
<!-- El shapes.js tiene las formas que usaremos, como el cubo -->
<script type="text/javascript" src="src/shapes.js"></script>
<!-- Para utilizar el requestAnimFrame() -->
<script type="text/javascript" src="src/utils/webgl-utils.js"></script>
<!-- Para los controles del teclado -->
<script type="text/javascript" src="src/utils/keyboard-and-mouse-support.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif

    precision mediump float;
	
	varying vec2 vTextureCoord; 
	varying vec3 vLightWeighting;
	
	uniform sampler2D uSampler; 

    void main(void) {
		vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
}
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;

    uniform mat4 uMMatrix;	
    uniform mat4 uVMatrix;
    uniform mat4 uPMatrix;
	
	uniform mat3 uNMatrix;
	
	uniform vec3 uLightingDirection;
	uniform vec3 uAmbientColor;	//la luz ambiente
	uniform vec3 uDirectionalColor;
	
	varying vec2 vTextureCoord;
	varying vec3 vLightWeighting;

    void main(void) {
        gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);	//los posiciona segun la matrix de proyección y la matriz de model-view
		vTextureCoord = aTextureCoord;
		vec3 transformedNormal = uNMatrix * aVertexNormal;
		float directionalLightWeighting = max(dot(normalize(transformedNormal), normalize(uLightingDirection)), 0.0);		
		vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;		
    }
</script>


<script type="text/javascript">

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var gl;
    function initGL(canvas) {
        try {
            gl = canvas.getContext("webgl");	//Mejora?
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("imposible iniciar webGL");
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    var shaderProgram;
    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
		
		shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
		
		shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
		gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.vMatrixUniform = gl.getUniformLocation(shaderProgram, "uVMatrix");
		shaderProgram.mMatrixUniform = gl.getUniformLocation(shaderProgram, "uMMatrix");
		shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
        shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightingDirection");
		shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
		shaderProgram.directionalColorUniform = gl.getUniformLocation(shaderProgram, "uDirectionalColor");
    }

    var mMatrix = mat4.create();
    var vMatrix = mat4.create();
    var pMatrix = mat4.create();
	var auxMat = mat4.create();
	var normalMatrix = mat3.create();
	
    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.vMatrixUniform, false, vMatrix);
        gl.uniformMatrix4fv(shaderProgram.mMatrixUniform, false, mMatrix);
		//mat4.multiply(auxMat, vMatrix, mMatrix);
		//mat3.normalFromMat4(normalMatrix, auxMat);
		mat3.normalFromMat4(normalMatrix, mMatrix);
		gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
    }
	
	var intensidadLuzAmbiente = 0.35;
	var intensidadSol = 0.35;
	function initLuces(){
	//Acá inicio mi primera luz que quiero que sea la de ambiente
		gl.uniform3f(shaderProgram.ambientColorUniform,intensidadLuzAmbiente,intensidadLuzAmbiente,intensidadLuzAmbiente+0.05);	//Luz tenue, el +0.05 es para que sea mas azul y le da efecto mas nocturno
	//Luz del sol
		var lightingDirection = [ 0.0, -1.0 , -0.5 ];
		var adjustedLD = vec3.create();
		vec3.normalize(adjustedLD, lightingDirection);
		vec3.scale(adjustedLD, adjustedLD, -1);
		gl.uniform3fv(shaderProgram.lightingDirectionUniform, adjustedLD);
	//Intensidad del sol
	    gl.uniform3f(shaderProgram.directionalColorUniform,intensidadSol+0.05,intensidadSol,intensidadSol);	//El +0.05 es para que sea mas anaranjado por el sol
	}
	
	var cameraPosition = vec3.create();
	var target = vec3.create();
	var cameraMode = 1; //uno es default orbital
	var moveXCrane = 0;
	var gruaAbajo = -3;
	var ruedasAncho = -0.5*0.97;	//sale de la escala que le puse a la rueda
	var scaleDeLasPinzas = 1;
	var moverCabina = 0;

	function initVariables () {
		//Esto que hago acá es para que pongas en coordenadas cartesianas X,Y,Z donde queres
		//que empiece la camara al iniciarse, y despues las traduzco a cordenadas esfericas
		var initPosToTranslate = vec3.create();
		vec3.set(initPosToTranslate,2.0,2.0,3.0);	//Aca pongo a donde quiero que vaya
		var radius = vec3.squaredLength(initPosToTranslate);
		thetaAngle = Math.acos(initPosToTranslate[2]/radius);	//para las rotaciones en zy e zx
		phiAngle = Math.atan(initPosToTranslate[1]/initPosToTranslate[0]);	//para las rotaciones en el plano xy
		target = [0,0,0];
		cameraPosition = [radius*Math.cos(phiAngle)*Math.sin(thetaAngle),radius*Math.sin(phiAngle)*Math.sin(thetaAngle),radius*Math.cos(thetaAngle)];
		initLuces();
	}
	
    function drawScene() {
		drawCrame(moveXCrane,2.0,1.0);   //incluye el piso por cuestiones de performance
		drawSky([0,0,0],[60,60,60],90,[1,0,0]);
		drawOcean([0,0,gruaAbajo+ruedasAncho-0.3],[55,55,1],waterTexture);							//Acá que vaya el mar
		drawMountain([-23,2,-7],[1.2,2.2,3.1],180,[0,0,1]);
		drawShip([5,0,0],[1.0,1.0,1.0], 0, [0,0,1]);
		drawContainers([3,1,-3],[1.25,0.5,0.5]);
    }
	
	function updateCamera(){
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);	//El tutorial dice que sirven
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);	//El tutorial dice que sirven
		mat4.lookAt(vMatrix,cameraPosition,target,[0.0,0.0,1.0]);
		mat4.perspective(pMatrix,degToRad(70), gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
	}
	
	function tick() {
		requestAnimFrame(tick);		
		handleKeyPresses();
		updateCamera();
        drawScene();
	}

	var widthOfCanvas;
	var heightOfCanvas;
    function webGLStart() {
        var canvas = document.getElementById("TP1C2015");	
		widthOfCanvas = document.getElementById("TP1C2015").width;
		heightOfCanvas = document.getElementById("TP1C2015").height;
		
		//Sacado de http://www.sitepoint.com/html5-javascript-mouse-wheel/
		if (canvas.addEventListener) {
			// IE9, Chrome, Safari, Opera
			canvas.addEventListener("mousewheel", MouseWheelHandler, false);
			// Firefox
			canvas.addEventListener("DOMMouseScroll", MouseWheelHandler, false);
		}
		// IE 6/7/8
		else canvas.attachEvent("onmousewheel", MouseWheelHandler);		

        initGL(canvas);
        initShaders();
        initObjects();	//Acá es donde iniciamos todas las cosas pesadas, como cilindro, montaña, esfera para que sea mas performante y lo sacamos de DrawShape
		initVariables();
		initTexture();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.enable(gl.DEPTH_TEST);
		
		//Agregando soporte para el movimiento con teclado(¿Y mouse también?):
		document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;
		
		tick();
    }
</script>
</head>


<body onload="webGLStart();">
    <canvas id="TP1C2015" onmousemove="onMouseMove(event)" onmousedown="onMouseDown(event)" onmouseup="onMouseUp(event)" style="border: none;" width="1400" height="640"></canvas>
	<div style="color:#0000FF;text-align:center;font: Helvetica 12pt;border: 1px solid black;">
		<div>Presione 1 para cámara orbital.</div>
		<div>Presione 2 para cámara primera persona. WASD para moverse en este modo.</div>
		<div>Presione Z/X para levantar o bajar las pinzas. C/V para mover la cabina. Q/E para mover la grúa.</div>
	</div>
</body>

</html>
